\hypertarget{class_x_bee_with_callbacks}{}\section{X\+Bee\+With\+Callbacks Class Reference}
\label{class_x_bee_with_callbacks}\index{X\+Bee\+With\+Callbacks@{X\+Bee\+With\+Callbacks}}


{\ttfamily \#include $<$X\+Bee.\+h$>$}



Inheritance diagram for X\+Bee\+With\+Callbacks\+:
% FIG 0


Collaboration diagram for X\+Bee\+With\+Callbacks\+:
% FIG 1
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{class_x_bee_with_callbacks_ad0e1a60d761641e8bd0349a615522b55}{on\+Packet\+Error} (void($\ast$func)(uint8\+\_\+t, uintptr\+\_\+t), uintptr\+\_\+t data=0)
\item 
void \hyperlink{class_x_bee_with_callbacks_ae1044a0b7dcde294bc8bc7d2ef9f68b1}{on\+Response} (void($\ast$func)(\hyperlink{class_x_bee_response}{X\+Bee\+Response} \&, uintptr\+\_\+t), uintptr\+\_\+t data=0)
\item 
void \hyperlink{class_x_bee_with_callbacks_aef62897f97a946cba21ba37c5ee2ef26}{on\+Other\+Response} (void($\ast$func)(\hyperlink{class_x_bee_response}{X\+Bee\+Response} \&, uintptr\+\_\+t), uintptr\+\_\+t data=0)
\item 
\hypertarget{class_x_bee_with_callbacks_a56368dae6464006924b434041f099c15}{}\label{class_x_bee_with_callbacks_a56368dae6464006924b434041f099c15} 
void {\bfseries on\+Z\+B\+Tx\+Status\+Response} (void($\ast$func)(\hyperlink{class_z_b_tx_status_response}{Z\+B\+Tx\+Status\+Response} \&, uintptr\+\_\+t), uintptr\+\_\+t data=0)
\item 
\hypertarget{class_x_bee_with_callbacks_ac07fca96fdcf05dc6c351bcd8d622865}{}\label{class_x_bee_with_callbacks_ac07fca96fdcf05dc6c351bcd8d622865} 
void {\bfseries on\+Z\+B\+Rx\+Response} (void($\ast$func)(\hyperlink{class_z_b_rx_response}{Z\+B\+Rx\+Response} \&, uintptr\+\_\+t), uintptr\+\_\+t data=0)
\item 
\hypertarget{class_x_bee_with_callbacks_a59f65d700b6d7fd143b96ca35370f2cf}{}\label{class_x_bee_with_callbacks_a59f65d700b6d7fd143b96ca35370f2cf} 
void {\bfseries on\+Z\+B\+Explicit\+Rx\+Response} (void($\ast$func)(\hyperlink{class_z_b_explicit_rx_response}{Z\+B\+Explicit\+Rx\+Response} \&, uintptr\+\_\+t), uintptr\+\_\+t data=0)
\item 
\hypertarget{class_x_bee_with_callbacks_aaa3cbb23eda4d4b8ad76e1a4993964d3}{}\label{class_x_bee_with_callbacks_aaa3cbb23eda4d4b8ad76e1a4993964d3} 
void {\bfseries on\+Z\+B\+Rx\+Io\+Sample\+Response} (void($\ast$func)(\hyperlink{class_z_b_rx_io_sample_response}{Z\+B\+Rx\+Io\+Sample\+Response} \&, uintptr\+\_\+t), uintptr\+\_\+t data=0)
\item 
\hypertarget{class_x_bee_with_callbacks_a12d60ecfce4aa1fcbea77e9afdb6b95e}{}\label{class_x_bee_with_callbacks_a12d60ecfce4aa1fcbea77e9afdb6b95e} 
void {\bfseries on\+Tx\+Status\+Response} (void($\ast$func)(\hyperlink{class_tx_status_response}{Tx\+Status\+Response} \&, uintptr\+\_\+t), uintptr\+\_\+t data=0)
\item 
\hypertarget{class_x_bee_with_callbacks_aac33b0171796babc04c317c2ac4c0ba0}{}\label{class_x_bee_with_callbacks_aac33b0171796babc04c317c2ac4c0ba0} 
void {\bfseries on\+Rx16\+Response} (void($\ast$func)(\hyperlink{class_rx16_response}{Rx16\+Response} \&, uintptr\+\_\+t), uintptr\+\_\+t data=0)
\item 
\hypertarget{class_x_bee_with_callbacks_aa2e75189434b4e59831a12dd5b5fab70}{}\label{class_x_bee_with_callbacks_aa2e75189434b4e59831a12dd5b5fab70} 
void {\bfseries on\+Rx64\+Response} (void($\ast$func)(\hyperlink{class_rx64_response}{Rx64\+Response} \&, uintptr\+\_\+t), uintptr\+\_\+t data=0)
\item 
\hypertarget{class_x_bee_with_callbacks_af205a513e7570258478c6c6e6c2f815b}{}\label{class_x_bee_with_callbacks_af205a513e7570258478c6c6e6c2f815b} 
void {\bfseries on\+Rx16\+Io\+Sample\+Response} (void($\ast$func)(\hyperlink{class_rx16_io_sample_response}{Rx16\+Io\+Sample\+Response} \&, uintptr\+\_\+t), uintptr\+\_\+t data=0)
\item 
\hypertarget{class_x_bee_with_callbacks_a8199354716ddf671b4726efba638a856}{}\label{class_x_bee_with_callbacks_a8199354716ddf671b4726efba638a856} 
void {\bfseries on\+Rx64\+Io\+Sample\+Response} (void($\ast$func)(\hyperlink{class_rx64_io_sample_response}{Rx64\+Io\+Sample\+Response} \&, uintptr\+\_\+t), uintptr\+\_\+t data=0)
\item 
\hypertarget{class_x_bee_with_callbacks_ae7211d3c7a99bad23e63a5dfbbf4b11c}{}\label{class_x_bee_with_callbacks_ae7211d3c7a99bad23e63a5dfbbf4b11c} 
void {\bfseries on\+Modem\+Status\+Response} (void($\ast$func)(\hyperlink{class_modem_status_response}{Modem\+Status\+Response} \&, uintptr\+\_\+t), uintptr\+\_\+t data=0)
\item 
\hypertarget{class_x_bee_with_callbacks_a44fbc2a39ff0b85eaa33e6b49dbd5c19}{}\label{class_x_bee_with_callbacks_a44fbc2a39ff0b85eaa33e6b49dbd5c19} 
void {\bfseries on\+At\+Command\+Response} (void($\ast$func)(\hyperlink{class_at_command_response}{At\+Command\+Response} \&, uintptr\+\_\+t), uintptr\+\_\+t data=0)
\item 
\hypertarget{class_x_bee_with_callbacks_a7a4ea0701ce4c376f492f723c992c322}{}\label{class_x_bee_with_callbacks_a7a4ea0701ce4c376f492f723c992c322} 
void {\bfseries on\+Remote\+At\+Command\+Response} (void($\ast$func)(\hyperlink{class_remote_at_command_response}{Remote\+At\+Command\+Response} \&, uintptr\+\_\+t), uintptr\+\_\+t data=0)
\item 
void \hyperlink{class_x_bee_with_callbacks_aec6a4688f09fef714c377ede587b5ba9}{loop} ()
\item 
{\footnotesize template$<$typename Response $>$ }\\uint8\+\_\+t \hyperlink{class_x_bee_with_callbacks_aca6a7f82b94c3d2dc4353c0a18404da7}{wait\+For} (Response \&response, uint16\+\_\+t timeout, bool($\ast$func)(Response \&, uintptr\+\_\+t)=N\+U\+LL, uintptr\+\_\+t data=0, int16\+\_\+t frame\+Id=-\/1)
\item 
uint8\+\_\+t \hyperlink{class_x_bee_with_callbacks_ab503dbf4de2376d68564ffff9a11d0c5}{send\+And\+Wait} (\hyperlink{class_x_bee_request}{X\+Bee\+Request} \&request, uint16\+\_\+t timeout)
\item 
uint8\+\_\+t \hyperlink{class_x_bee_with_callbacks_acc987ba525278080c3cbe2db1d2ed249}{wait\+For\+Status} (uint8\+\_\+t frame\+Id, uint16\+\_\+t timeout)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
This class can be used instead of the \hyperlink{class_x_bee}{X\+Bee} class and allows user-\/specified callback functions to be called when responses are received, simplifying the processing code and reducing boilerplate.

To use it, first register your callback functions using the on\+Xxx methods. Each method has a uintptr\+\_\+t data argument, that can be used to pass arbitrary data to the callback (useful when using the same function for multiple callbacks, or have a generic function that can behave differently in different circumstances). Supplying the data parameter is optional, but the callback must always accept it (just ignore it if it\textquotesingle{}s unused). The uintptr\+\_\+t type is an integer type guaranteed to be big enough to fit a pointer (it is 16-\/bit on A\+VR, 32-\/bit on A\+RM), so it can also be used to store a pointer to access more data if required (using proper casts).

There can be only one callback of each type registered at one time, so registering callback overwrites any previously registered one. To unregister a callback, pass N\+U\+LL as the function.

To ensure that the callbacks are actually called, call the \hyperlink{class_x_bee_with_callbacks_aec6a4688f09fef714c377ede587b5ba9}{loop()} method regularly (in your \hyperlink{class_x_bee_with_callbacks_aec6a4688f09fef714c377ede587b5ba9}{loop()} function, for example). This takes care of calling \hyperlink{class_x_bee_a7d788232f44e8b3c10dc686a0299fcc6}{read\+Packet()} and \hyperlink{class_x_bee_a18250def80e8b643aa1ccc15a98937f3}{get\+Response()} other methods on the \hyperlink{class_x_bee}{X\+Bee} class, so there is no need to do so directly (though it should not mess with this class if you do, it would only mean some callbacks aren\textquotesingle{}t called).

Inside callbacks, you should generally not be blocking / waiting. Since callbacks can be called from inside \hyperlink{class_x_bee_with_callbacks_aca6a7f82b94c3d2dc4353c0a18404da7}{wait\+For()} and friends, a callback that doesn\textquotesingle{}t return quickly can mess up the \hyperlink{class_x_bee_with_callbacks_aca6a7f82b94c3d2dc4353c0a18404da7}{wait\+For()} timeout.

Sending packets is not a problem inside a callback, but avoid receiving a packet (e.\+g. calling \hyperlink{class_x_bee_a7d788232f44e8b3c10dc686a0299fcc6}{read\+Packet()}, \hyperlink{class_x_bee_with_callbacks_aec6a4688f09fef714c377ede587b5ba9}{loop()} or \hyperlink{class_x_bee_with_callbacks_aca6a7f82b94c3d2dc4353c0a18404da7}{wait\+For()} and friends) inside a callback (since that would overwrite the current response, messing up any pending callbacks and \hyperlink{class_x_bee_with_callbacks_aca6a7f82b94c3d2dc4353c0a18404da7}{wait\+For()} etc. methods already running). 

\subsection{Member Function Documentation}
\hypertarget{class_x_bee_with_callbacks_aec6a4688f09fef714c377ede587b5ba9}{}\label{class_x_bee_with_callbacks_aec6a4688f09fef714c377ede587b5ba9} 
\index{X\+Bee\+With\+Callbacks@{X\+Bee\+With\+Callbacks}!loop@{loop}}
\index{loop@{loop}!X\+Bee\+With\+Callbacks@{X\+Bee\+With\+Callbacks}}
\subsubsection{\texorpdfstring{loop()}{loop()}}
{\footnotesize\ttfamily void X\+Bee\+With\+Callbacks\+::loop (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Regularly call this method, which ensures that the serial buffer is processed and the appropriate callbacks are called. \hypertarget{class_x_bee_with_callbacks_aef62897f97a946cba21ba37c5ee2ef26}{}\label{class_x_bee_with_callbacks_aef62897f97a946cba21ba37c5ee2ef26} 
\index{X\+Bee\+With\+Callbacks@{X\+Bee\+With\+Callbacks}!on\+Other\+Response@{on\+Other\+Response}}
\index{on\+Other\+Response@{on\+Other\+Response}!X\+Bee\+With\+Callbacks@{X\+Bee\+With\+Callbacks}}
\subsubsection{\texorpdfstring{on\+Other\+Response()}{onOtherResponse()}}
{\footnotesize\ttfamily void X\+Bee\+With\+Callbacks\+::on\+Other\+Response (\begin{DoxyParamCaption}\item[{void($\ast$)(\hyperlink{class_x_bee_response}{X\+Bee\+Response} \&, uintptr\+\_\+t)}]{func,  }\item[{uintptr\+\_\+t}]{data = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Register an other response received callback. It is called whenever a response was succesfully received, but no response specific callback was registered using the functions below (after the on\+Response callback is called).

Arguments to the callback will be the received response and the data parameter passed while registering the callback. \hypertarget{class_x_bee_with_callbacks_ad0e1a60d761641e8bd0349a615522b55}{}\label{class_x_bee_with_callbacks_ad0e1a60d761641e8bd0349a615522b55} 
\index{X\+Bee\+With\+Callbacks@{X\+Bee\+With\+Callbacks}!on\+Packet\+Error@{on\+Packet\+Error}}
\index{on\+Packet\+Error@{on\+Packet\+Error}!X\+Bee\+With\+Callbacks@{X\+Bee\+With\+Callbacks}}
\subsubsection{\texorpdfstring{on\+Packet\+Error()}{onPacketError()}}
{\footnotesize\ttfamily void X\+Bee\+With\+Callbacks\+::on\+Packet\+Error (\begin{DoxyParamCaption}\item[{void($\ast$)(uint8\+\_\+t, uintptr\+\_\+t)}]{func,  }\item[{uintptr\+\_\+t}]{data = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Register a packet error callback. It is called whenever an error occurs in the packet reading process. Arguments to the callback will be the error code (as returned by \hyperlink{class_x_bee_response_a2895438378d2738e3efe74b1c838170b}{X\+Bee\+Response\+::get\+Error\+Code()}) and the data parameter. while registering the callback. \hypertarget{class_x_bee_with_callbacks_ae1044a0b7dcde294bc8bc7d2ef9f68b1}{}\label{class_x_bee_with_callbacks_ae1044a0b7dcde294bc8bc7d2ef9f68b1} 
\index{X\+Bee\+With\+Callbacks@{X\+Bee\+With\+Callbacks}!on\+Response@{on\+Response}}
\index{on\+Response@{on\+Response}!X\+Bee\+With\+Callbacks@{X\+Bee\+With\+Callbacks}}
\subsubsection{\texorpdfstring{on\+Response()}{onResponse()}}
{\footnotesize\ttfamily void X\+Bee\+With\+Callbacks\+::on\+Response (\begin{DoxyParamCaption}\item[{void($\ast$)(\hyperlink{class_x_bee_response}{X\+Bee\+Response} \&, uintptr\+\_\+t)}]{func,  }\item[{uintptr\+\_\+t}]{data = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Register a response received callback. It is called whenever a response was succesfully received, before a response specific callback (or on\+Other\+Response) below is called.

Arguments to the callback will be the received response and the data parameter passed while registering the callback. \hypertarget{class_x_bee_with_callbacks_ab503dbf4de2376d68564ffff9a11d0c5}{}\label{class_x_bee_with_callbacks_ab503dbf4de2376d68564ffff9a11d0c5} 
\index{X\+Bee\+With\+Callbacks@{X\+Bee\+With\+Callbacks}!send\+And\+Wait@{send\+And\+Wait}}
\index{send\+And\+Wait@{send\+And\+Wait}!X\+Bee\+With\+Callbacks@{X\+Bee\+With\+Callbacks}}
\subsubsection{\texorpdfstring{send\+And\+Wait()}{sendAndWait()}}
{\footnotesize\ttfamily uint8\+\_\+t X\+Bee\+With\+Callbacks\+::send\+And\+Wait (\begin{DoxyParamCaption}\item[{\hyperlink{class_x_bee_request}{X\+Bee\+Request} \&}]{request,  }\item[{uint16\+\_\+t}]{timeout }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Sends a \hyperlink{class_x_bee_request}{X\+Bee\+Request} (TX packet) out the serial port, and wait for a status response A\+PI frame (up until the given timeout). Essentially this just calls \hyperlink{class_x_bee_a802387f468be8622941d16739ac848f2}{send()} and \hyperlink{class_x_bee_with_callbacks_acc987ba525278080c3cbe2db1d2ed249}{wait\+For\+Status()}. See wait\+For\+Status for the meaning of the return value and more details. \hypertarget{class_x_bee_with_callbacks_aca6a7f82b94c3d2dc4353c0a18404da7}{}\label{class_x_bee_with_callbacks_aca6a7f82b94c3d2dc4353c0a18404da7} 
\index{X\+Bee\+With\+Callbacks@{X\+Bee\+With\+Callbacks}!wait\+For@{wait\+For}}
\index{wait\+For@{wait\+For}!X\+Bee\+With\+Callbacks@{X\+Bee\+With\+Callbacks}}
\subsubsection{\texorpdfstring{wait\+For()}{waitFor()}}
{\footnotesize\ttfamily template$<$typename Response $>$ \\
uint8\+\_\+t X\+Bee\+With\+Callbacks\+::wait\+For (\begin{DoxyParamCaption}\item[{Response \&}]{response,  }\item[{uint16\+\_\+t}]{timeout,  }\item[{bool($\ast$)(Response \&, uintptr\+\_\+t)}]{func = {\ttfamily NULL},  }\item[{uintptr\+\_\+t}]{data = {\ttfamily 0},  }\item[{int16\+\_\+t}]{frame\+Id = {\ttfamily -\/1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Wait for a A\+PI response of the given type, optionally filtered by the given match function.

If a match function is given it is called for every response of the right type received, passing the response and the data parameter passed to this method. If the function returns true (or if no function was passed), waiting stops and this method returns 0. If the function returns false, waiting continues. After the given timeout passes, this method returns X\+B\+E\+E\+\_\+\+W\+A\+I\+T\+\_\+\+T\+I\+M\+E\+O\+UT.

If a valid frame\+Id is passed (e.\+g. 0-\/255 inclusive) and a status A\+PI response frame is received while waiting, that has a {\itshape non-\/zero} status, waiting stops and that status is received. This is intended for when a TX packet was sent and you are waiting for an RX reply, which will most likely never arrive when TX failed. However, since the status reply is not guaranteed to arrive before the RX reply (a remote module can send a reply before the A\+CK), first calling \hyperlink{class_x_bee_with_callbacks_acc987ba525278080c3cbe2db1d2ed249}{wait\+For\+Status()} and then \hyperlink{class_x_bee_with_callbacks_aca6a7f82b94c3d2dc4353c0a18404da7}{wait\+For()} can sometimes miss the reply RX packet.

Note that when the intended response is received {\itshape before} the status reply, the latter will not be processed by this method and will be subsequently processed by e.\+g. \hyperlink{class_x_bee_with_callbacks_aec6a4688f09fef714c377ede587b5ba9}{loop()} normally.

While waiting, any other responses received are passed to the relevant callbacks, just as if calling \hyperlink{class_x_bee_with_callbacks_aec6a4688f09fef714c377ede587b5ba9}{loop()} continuously (except for the response sought, that one is only passed to the On\+Response handler and no others).

After this method returns, the response itself can still be retrieved using \hyperlink{class_x_bee_a18250def80e8b643aa1ccc15a98937f3}{get\+Response()} as normal. \hypertarget{class_x_bee_with_callbacks_acc987ba525278080c3cbe2db1d2ed249}{}\label{class_x_bee_with_callbacks_acc987ba525278080c3cbe2db1d2ed249} 
\index{X\+Bee\+With\+Callbacks@{X\+Bee\+With\+Callbacks}!wait\+For\+Status@{wait\+For\+Status}}
\index{wait\+For\+Status@{wait\+For\+Status}!X\+Bee\+With\+Callbacks@{X\+Bee\+With\+Callbacks}}
\subsubsection{\texorpdfstring{wait\+For\+Status()}{waitForStatus()}}
{\footnotesize\ttfamily uint8\+\_\+t X\+Bee\+With\+Callbacks\+::wait\+For\+Status (\begin{DoxyParamCaption}\item[{uint8\+\_\+t}]{frame\+Id,  }\item[{uint16\+\_\+t}]{timeout }\end{DoxyParamCaption})}

Wait for a status A\+PI response with the given frame\+Id and return the status from the packet (for Z\+B\+\_\+\+T\+X\+\_\+\+S\+T\+A\+T\+U\+S\+\_\+\+R\+E\+S\+P\+O\+N\+SE, this returns just the delivery status, not the routing status). If the timeout is reached before reading the response, X\+B\+E\+E\+\_\+\+W\+A\+I\+T\+\_\+\+T\+I\+M\+E\+O\+UT is returned instead.

While waiting, any other responses received are passed to the relevant callbacks, just as if calling \hyperlink{class_x_bee_with_callbacks_aec6a4688f09fef714c377ede587b5ba9}{loop()} continuously (except for the status response sought, that one is only passed to the On\+Response handler and no others).

After this method returns, the response itself can still be retrieved using \hyperlink{class_x_bee_a18250def80e8b643aa1ccc15a98937f3}{get\+Response()} as normal. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/\+Goh Eng Wei/\+Documents/\+Arduino/libraries/\+X\+Bee/X\+Bee.\+h\item 
C\+:/\+Users/\+Goh Eng Wei/\+Documents/\+Arduino/libraries/\+X\+Bee/X\+Bee.\+cpp\end{DoxyCompactItemize}
